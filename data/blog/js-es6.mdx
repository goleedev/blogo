---
title: '😎 자바스크립트 ES6란'
thumbSrc: '/static/images/js29.png'
date: '2021-07-22'
tags: ['FE', 'JavaScript']
draft: false
summary: '모던 자바스크립트를 학습하며 정리한 자료로 ES6에 대해 설명합니다.'
images: ['/static/images/js29.png']
authors: ['default']
---

# 📌 목차

![JS ES6](/static/images/js29.png)

- **💁🏻 ES6란**

---

# 💁🏻 ES6란

**ECMAScript 2015**로도 알려져 있는 `ECMAScript 6`는 ECMAScript 표준의 버전 중 하나입니다. ES6는 2009년도에 표준화된 **ES5 이후로 언어 기능에 대한 첫 업데이트**이기도 합니다. 또한, ES6는 아래의 기능들을 포함하고 있습니다.

- **`const` and `let`**
- **Arrow functions** (화살표 함수)
- **Template Literals** (템플릿 리터럴)
- **Default parameters** (기본 매개 변수)
- **Array and object destructing** (배열 및 객체 비구조화)
- **Import and export** (모듈 가져오기 및 내보내기)
- **Promises** (프로미스)
- **Rest parameter and Spread operator** (나머지 매개 변수 및 확산 연산자)
- **Classes** (클래스)

## `const` and `let`

`const`는 변수 선언을 위한 ES6의 새로운 키워드로 `var`보다 강력하고 일단 사용되면 변수를 재할당할 수 없습니다. 즉, 객체와 함께 사용할 때를 제외하고는 **변경 불가능한 변수** 입니다. 이 기능은 선택자를 대상으로 하는 데 매우 유용합니다.

```javascript
// ES5
var btn = document.getElementById('mybtn')

// ES6
const btn = document.getElementById('mybtn')

// 위의 코드에서 const는 변경되지 않으며 재할당할 수 없습니다. 새로운 값을 제공하려고 하면 오류가 반환됩니다.
// let은 새로운 값을 가질 수도 있고 재할당할 수도 있습니다. 변경 가능한 변수가 생성됩니다.

let name = 'me'

name = 'you'

console.log(name)
// 출력: you
```

`let`은 `const`와 동일하게 모두 **블록 범위**라는 점입니다. 즉, **변수는 범위 내에서만 사용**할 수 있습니다.

## Arrow functions (화살표 함수)

화살표 함수는 코드를 **더 읽기 쉽고 더 체계적이고 최신 코드**처럼 보이게 합니다.

```javascript
// ES5
function myFunc(name) {
  return '안녕' + name
}

console.log(myFunc('GO'))

// 출력: 안녕 GO

// ES6 화살표 함수
const myFunc = (name) => {
  return `안녕 ${name}`
}

console.log(myFunc('GO')) // 출력 => 안녕 GO

// 또는 화살표를 사용하거나 'return' 키워드를 사용하지 않아도 됩니다
const myFunc = (name) => `안녕 ${name}`
```

## Template Literals(템플릿 리터럴)

템플릿 리터럴 또는 템플릿 문자열은 문자열을 연결하기 위해 더하기(+) 연산자를 사용할 필요는 없으며, **백틱(`)을 사용하여 문자열 내에서 변수를 사용**할 수도 있습니다.

```javascript
// ES5
function myFunc1() {
  return '안녕' + name + '당신의 나이는' + age + '살 이다!'
}

console.log(myFunc1('GO', 20))
// 출력 => 안녕 GO 당신의 나이는 20살 이다!

// ES6
const myFunc = (name, age) => {
  return `안녕 ${name}, 당신의 나이는 ${age}살 이다!`
}

console.log(myFunc1('GO', 20))
// 출력 => 안녕 GO, 당신의 나이는 20살 이다!
```

## Default parameters (기본 매개 변수)

매개 변수를 쓰지 않은 경우 매개 변수가 이미 기본값에 정의되어 있으므로 정의되지 않은 오류가 반환되지 않습니다. 따라서 **누락된 매개 변수를 사용하여 함수를 실행할 때 기본 매개 변수 t 값을 사용하고 오류를 반환하지 않습니다**.

```javascript
// ES5
const myFunc = (name, age) => {
  return `안녕 ${name} 당신의 나이는 ${age}살 이니?`
}

console.log(myFunc1('GO'))
// 출력 => 안녕 GO 당신의 나이는 undefined살 이니?

// ES6
const myFunc = (name, age = 20) => {
  return `안녕 ${name} 당신의 나이는 ${age}살 이니?`
}

console.log(myFunc1('GO'))
// 출력 => 안녕 GO 당신의 나이는 20살 이니?
```

## Array and object destructing (배열 및 객체 비구조화)

`비구조화`를 통해 배열 또는 객체의 값을 새 변수에 더 쉽게 할당할 수 있습니다.

```javascript
// ES5
const contacts = {
  famillyName: 'LEE',
  name: 'GO',
  age: 20,
}

let famillyName = contacts.famillyName
let name = contacts.name
let myAge = contacts.age

console.log(famillyName)
console.log(name)
console.log(age)
// 출력:
// LEE
// GO
// 20

// ES6
const contacts = {
  famillyName: 'LEE',
  name: 'GO',
  age: 20,
}

let { famillyName, name, age } = contacts

console.log(famillyName)
console.log(name)
console.log(age)
// 출력:
// LEE
// GO
// 20
```

## Import and export (모듈 가져오기 및 내보내기)

JavaScript 응용프로그램에서 `import` 및 `export`를 사용하면 성능이 향상됩니다. 이를 통해 별도의 **재사용 가능한 구성요소를 작성**할 수 있습니다. `export`를 사용하면 다른 JavaScript 구성 요소에 사용할 **모듈을 내보낼 수 있습니다**. 이때, 모듈을 컴포넌트에 사용하기 위해 가져오기 `import`를 사용합니다.

## Promises (프로미스)

`Promise`는 ES6의 새로운 특징이자 **비동기 코드를 쓰는 방법**입니다. 예를 들어 **API에서 데이터를 가져오거나 실행하는데 시간이 걸리는 함수를 가지고 있을 때 사용**할 수 있습니다.

```javascript
const myPromise = () => {
  return new Promise((resolve, reject) => {
    resolve('안녕하세요 Promise가 성공적으로 실행했습니다')
  })
}

cosole.log(myPromise())
// Promise {<resolved>: "안녕하세요 Promise가 성공적으로 실행했습니다"}
// 콘솔을 기록하면 Promise가 반환됩니다. 따라서 데이터를 가져온 후 함수를 실행하려면 Promise를 사용합니다. Promise는 두 개의 매개 변수를 사용하며 resolve및 reject 예상 오류를 처리 할 수 있습니다.

const url = 'https://jsonplaceholder.typicode.com/posts'
const getData = (url) => {
  return fetch(url)
}

getData(url)
  .then((data) => data.json())
  .then((result) => console.log(result))
// 이제 콘솔을 기록하면 데이터 배열이 반환됩니다.
```

## Rest parameter and Spread operator (나머지 매개 변수 및 확산 연산자)

`Rest parameter`는 배열의 인수를 가져오고 **새 배열을 반환**하는데 사용됩니다.

```javascript
const arr = ['GO', 20, '애증의 자바스크립트', '안녕', 'Tom', '어떻게 지내니?']

// 비구조화를 이용한 값을 얻기
const [val1, val2, val3, ...rest] = arr

const Func = (restOfArr) => {
  return restOfArr
    .filter((item) => {
      return item
    })
    .join(' ')
}

console.log(Func(rest)) // 안녕 Tom 어떻게 지내니?
// Spread operator는 Rest parameter와 구문이 동일하지만 Spread operator는 인수뿐만 아니라 배열 자체를 가집니다. for 반복문이나 다른 메서드를 사용하는 대신 Spread operator를 사용하여 배열의 값을 가져올 수 있습니다.

const arr = ['GO', 20, '애증의 자바스크립트', '안녕', 'Tom', '어떻게 지내니?']

const Func = (...anArray) => {
  return anArray
}

console.log(Func(arr))
// 출력: ['GO', 20, '애증의 자바스크립트', '안녕', 'Tom', '어떻게 지내니?'];
```

## Classes (클래스)

`class`는 **객체 지향 프로그래밍 (OOP)의 핵심**이며 코드를 더욱 안전하게 **캡슐화**할 수 있습니다. `class`를 만들려면 `class` 키워드 뒤에 두 개의 중괄호가 있는 `class` 이름을 사용합니다. 이떄 `new 키워드`를 사용하면 `class` 메서드와 속성에 액세스할 수 있습니다.

```javascript
class myClass {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

const user = new myClass('GO', 20)

console.log(user.name) // GO
console.log(user.age) // 20

// 다른 class에서 상속하려면 extends 키워드 다음에 상속할 class의 이름을 사용합니다.
class myClass {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  sayHello() {
    console.log(`안녕 ${this.name} 당신의 나이는 ${this.age}살이다`)
  }
}

// myClass 메서드 및 속성 상속
class UserProfile extends myClass {
  userName() {
    console.log(this.name)
  }
}

const profile = new UserProfile('GO', 20)

profile.sayHello() // 안녕 GO 당신의 나이는 20살이다.
profile.userName() // GO
```

---

### 🔗 References

[JavaScript ES6 — write less, do more](https://www.freecodecamp.org/news/write-less-do-more-with-javascript-es6-5fd4a8e50ee2/)

[ECMAScript 6](https://github.com/lukehoban/es6features)
